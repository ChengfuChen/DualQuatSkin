<!DOCTYPE html>
<!-- saved from url=(0054)http://marcinignac.com/experiments/ssao/v01/index.html -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title></title>
<meta charset="UTF-8">                             
<!--
<script type="text/javascript" src="js/webglinspector/core/embed2.js"></script>
-->
<script type="text/javascript" src="./index_files/pregl.js"></script>
<script type="text/javascript" src="./index_files/preglext.js"></script>
<script type="text/javascript" src="./index_files/seedrandom.js"></script>
<script>                    
/*     
SSAO from http://www.john-chapman.net/content.php?id=8 

*/                
window.onload = function() {        
	var canvas = document.getElementById("canvas");
	var gl = PreGL.WebGL.getContext(canvas); 
	//gl = PreGL.WebGL.wrappedContextWithErrorChecks(gl);
	var time = 0;  
	var sphere;   
	var plane;    		
	var renderDepthShader;    
	var blurShader;	
	var ssaoFSQuad;             
	var ssaoShader;   
	var noiseTexture;
	var depthFbo; 
	var normalFbo;     
	var ssaoFbo;    
	var prevTime = 0;  
	var fpsFrames = 0;
	var fpsTime = 0;
	var fps = 0; 
	var kernel = [];
	function setup() {     
		var supported = gl.getSupportedExtensions();                  
		PreGLExt.log("Supported WebGL extensions: " + supported);  		
		renderDepthShader = new Shader(gl, "showDepth.vert", "showDepth.frag");   		
		ssaoShader = new Shader(gl, "ssao.vert", "ssao.frag");                    		
		blurShader = new Shader(gl, "baseTexture.vert", "blur.frag");
		sphere = SimpleMesh.buildSphere(gl, 1);	 
		plane = SimpleMesh.buildPlaneXY(gl, 1, 1);   	
		ssaoFSQuad = new FullScreenQuad(gl);
		
		var w = 1024;
		var h = 512;
		depthFbo = new FBO(gl, w, h); 
		normalFbo = new FBO(gl, w, h);  
		ssaoFbo = new FBO(gl, w, h);
		
		noiseTexture = genNoiseTextureRGBA(gl, 4, 4);  
		
		prevTime = (new Date()).getTime();  
		
		
		var kernelSize = 16;
		for(var i=0; i<kernelSize; i++) {
			kernel.push(2.0 * (Math.random() - 0.5));
			kernel.push(2.0 * (Math.random() - 0.5));
			kernel.push(Math.random());				
		}
	}             		 		
	function draw() {        
		var currTime = (new Date()).getTime();
		var deltaTime = (currTime - prevTime)/1000;
		prevTime = currTime;		                              
		time += deltaTime;	  
		fpsTime += deltaTime;
		fpsFrames++;
		if (fpsTime > 5) {
			fps = fpsFrames / fpsTime;
			fpsTime = 0;   
			fpsFrames = 0;			
			PreGLExt.log("FPS : " + fps);  
		}          
		
		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);						
		gl.enable(gl.DEPTH_TEST);      
		
		var cameraPos = new PreGL.Vec3(4 * Math.cos(time), 0, 4 * Math.sin(time));
		var camera = new PerspectiveCamera(60, depthFbo.width/depthFbo.height, 1, 20, cameraPos);
		
		PreGLExt.once("camera frustum", function() {
		   var frustumCorners = camera.getFrustumCorners();
		});

	    depthFbo.bind();		
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.viewport(0, 0, depthFbo.width, depthFbo.height);                               	  
		renderScene(camera, renderDepthShader, time); 
		depthFbo.unbind(); 
		
		//ssaoFbo.bind();    
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.viewport(0, 0, ssaoFbo.width, ssaoFbo.height);
		ssaoShader.use();           			
		ssaoShader.set("depthTex", 0);    
		ssaoShader.set("noiseTex", 1);    
		ssaoShader.set("fov", camera.fov/180*Math.PI);  
		ssaoShader.set("aspectRatio", camera.aspectRatio);
		ssaoShader.set("noiseScale", [depthFbo.width/noiseTexture.width, depthFbo.height/noiseTexture.height]); //4 = noise texture width
		ssaoShader.set("kernel", kernel);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, depthFbo.colorBuffer);    
		gl.activeTexture(gl.TEXTURE1);            
		gl.bindTexture(gl.TEXTURE_2D, noiseTexture); 
		renderScene(camera, ssaoShader, time);
		gl.activeTexture(gl.TEXTURE0);  
 		//ssaoFbo.unbind();  
 		/*
		blurShader.use();           			
		blurShader.set("colorTex", 0);    
		blurShader.set("texelSize", [1/ssaoFbo.width, 1/ssaoFbo.height]);
		gl.activeTexture(gl.TEXTURE0);
 		gl.bindTexture(gl.TEXTURE_2D, ssaoFbo.colorBuffer);    
		ssaoFSQuad.draw(blurShader); 
		gl.activeTexture(gl.TEXTURE0);
		 */
		
		//gl.viewport(0, 0, canvas.width, canvas.height);  
		
		requestAnimFrame(draw, canvas);
	}               
	function renderScene(camera, shader, time) {
		shader.use();           
		shader.set("projectionMatrix", camera.projectionMatrix);		
		shader.set("normalMatrix", camera.viewMatrix);		
		shader.set("near", camera.near);
		shader.set("far", camera.far);    
		      
		Math.seedrandom('spheres');        
		for(var i=0; i<30; i++) {        
			var scale = 0.25 + Math.random() * 0.25;                         
			var x = (Math.random() - 0.5) * 2.0;
			var y = (Math.random() - 0.5) * 2.0;
			var z = (Math.random() - 0.5) * 2.0;
			if (i<0) {
				var pos = new PreGL.Vec3(x, y, z);
				pos = pos.normalized().scaled(8);
				x = pos.x;
				y = pos.y;
				z = pos.z;   
				scale = 3;
			}   
			else {
				x = Math.cos(time + x);    
				y = Math.sin(time + y);  				
			}
			var modelViewMatrix = camera.getModelViewMatrix([x, y, z], null, [scale, scale, scale]);			
			shader.set("modelViewMatrix", modelViewMatrix);                                         
			var normalMatrix = modelViewMatrix.invert().transpose();
			shader.set("normalMatrix", normalMatrix);
			sphere.draw(shader);	
		}  	           
		
		var modelViewMatrix = camera.getModelViewMatrix([0, 0, 0.01], null, [3, 1, 1]);			
		shader.set("modelViewMatrix", modelViewMatrix);                                         
		var normalMatrix = modelViewMatrix.invert().transpose();
		shader.set("normalMatrix", normalMatrix);
		plane.draw(shader);	
		
 		modelViewMatrix = camera.getModelViewMatrix([0, 0, -0.01], [Math.PI, 0, 1, 0], [3, 1, 1]);			
		shader.set("modelViewMatrix", modelViewMatrix);                                         
		normalMatrix = modelViewMatrix.invert().transpose();
		shader.set("normalMatrix", normalMatrix);   
		plane.draw(shader);	 
	}
	function start() {
		//setInterval(draw, 1000/60);
		requestAnimFrame(draw, canvas);
	}       
	setup();     		
	start();
}                            	
</script>
<script type="glsl" id="base.vert">
	attribute vec4 position;
	attribute vec3 normal;
	attribute vec2 texCoord;

	uniform mat4 projectionMatrix;
	uniform mat4 modelViewMatrix;  

	varying vec3 vN;
	varying vec2 vTexCoord;  

	void main() {	
		gl_Position = projectionMatrix * modelViewMatrix * position;
		vN = normal;            
	   	vTexCoord = texCoord;
	}
</script>
<script type="glsl" id="baseTexture.vert">
	attribute vec4 position;
	attribute vec2 texCoord;

	uniform mat4 projectionMatrix;
	uniform mat4 modelViewMatrix;  

	varying vec2 vTexCoord;

	void main() {	
		gl_Position = projectionMatrix * modelViewMatrix * position;
	   	vTexCoord = texCoord;
	}
</script>                     
<script type="glsl" id="solidColor.frag">  
	uniform vec4 color;

	void main() {
		gl_FragColor = color;
	}
</script>
<script type="glsl" id="showNormal.frag">  
	varying vec3 vN;

	void main() {
		gl_FragColor.rgb = vN*0.5 + 0.5;
		gl_FragColor.a = 1.0;
	}
</script>
<script type="glsl" id="showTexCoord.frag">  
	varying vec2 vTexCoord;

	void main() {
		gl_FragColor.rg = vTexCoord;
		gl_FragColor.a = 1.0;
	}
</script> 
<script type="glsl" id="baseTexture.frag">  
	uniform sampler2D diffuseTex;
	varying vec2 vTexCoord; 	

	void main() {
		gl_FragColor.rgba = texture2D(diffuseTex, vTexCoord);
		gl_FragColor.a = 1.0;
	}
</script>  
<script type="glsl" id="baseTexture.frag">  
	uniform sampler2D diffuseTex;
	varying vec2 vTexCoord; 	

	void main() {
		gl_FragColor.rgba = texture2D(diffuseTex, vTexCoord);
		gl_FragColor.a = 1.0;
	}
</script>         
<script type="glsl" id="showDepth.vert">    
	attribute vec4 position;
	attribute vec3 normal;
	attribute vec2 texCoord;

	uniform mat4 projectionMatrix;
	uniform mat4 modelViewMatrix;  	
	uniform mat4 normalMatrix;  	
	uniform float near;
	uniform float far;

	varying vec3 vN;
	varying vec2 vTexCoord;
	varying float depth;                                            
	varying vec4 vVSPos;
	void main() {	
		gl_Position = projectionMatrix * modelViewMatrix * position;		
		vN = normalize((normalMatrix * vec4(normal, 1.0)).xyz);
		
		//linear depth in camera space (0..far)
		depth = (modelViewMatrix * position).z/far;
				
	   	vTexCoord = texCoord;        
		vVSPos = modelViewMatrix * position;
	}                        

</script>
<script type="glsl" id="showDepth.frag"> 
	#ifdef GL_ES
	precision highp float;
	#endif          
	uniform float near;
	uniform float far;

	varying float depth;   
	varying vec3 vN;     
	varying vec4 vVSPos;  

	//from http://spidergl.org/example.php?id=6
	vec4 packDepth(const in float depth) {
		const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
		vec4 res = fract(depth * bit_shift);
		res -= res.xxyz * bit_mask;
		return res;    		
	}

	void main() {         
		gl_FragData[0] = packDepth(-depth);
		gl_FragData[0].r = -depth/far;
	}
</script>  
<script type="glsl" id="ssao.vert">  
	attribute vec4 position;
	attribute vec3 normal;
	attribute vec2 texCoord;
	
	uniform mat4 projectionMatrix;
	uniform mat4 modelViewMatrix;  
	uniform mat4 normalMatrix;  

	varying vec3 vNormal;
	varying vec2 vTexCoord;  

	void main() {	
		gl_Position = projectionMatrix * modelViewMatrix * position;
		vNormal = (normalMatrix * vec4(normal, 1.0)).xyz;
	   	vTexCoord = texCoord;
	}
</script>
<script type="glsl" id="ssao.frag">  
	uniform sampler2D depthTex;
	uniform sampler2D noiseTex;  
	varying vec3 vNormal;
	uniform mat4 projectionMatrix;
	uniform mat4 m;
	uniform vec2 noiseScale;
	uniform float near;
	uniform float far;            
	uniform float fov;
	uniform float aspectRatio;    
	uniform vec3 kernel[16];   
	
	varying vec2 vTexCoord;   

	const int kernelSize = 16;  
	const float radius = 0.1;      

	float unpackDepth(const in vec4 rgba_depth) {
		const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
		float depth = dot(rgba_depth, bit_shift);
		return depth;
	}                

	vec3 getViewRay(vec2 tc) {
		float hfar = 2.0 * tan(fov/2.0) * far;
		float wfar = hfar * aspectRatio;    
		vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    
		return ray;                      
	}         
	           
	//linear view space depth
	float getDepth(vec2 coord) {                          
		return unpackDepth(texture2D(depthTex, coord.xy));
	}    
	
	void main() {          
		vec2 screenPos = vec2(gl_FragCoord.x / 1024.0, gl_FragCoord.y / 512.0);		                 
		//screenPos.y = 1.0 - screenPos.y;   
		
		
		float linearDepth = getDepth(screenPos);          
		vec3 origin = getViewRay(screenPos) * linearDepth;   
				
		vec3 normal = normalize(vNormal);   
				
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;
	    vec3 tangent = normalize(rvec - normal * dot(rvec, normal));
	    vec3 bitangent = cross(normal, tangent);
		mat3 tbn = mat3(tangent, bitangent, normal);        
		
		float occlusion = 0.0;
		for(int i = 0; i < kernelSize; ++i) {    	 
			vec3 sample = origin + (tbn * kernel[i]) * radius;
		    vec4 offset = projectionMatrix * vec4(sample, 1.0);		
			offset.xy /= offset.w;
			offset.xy = offset.xy * 0.5 + 0.5;        
		    float sampleDepth = -sample.z/far;
			float depthBufferValue = getDepth(offset.xy);				              
			float range_check = abs(linearDepth - depthBufferValue);
			if (range_check < radius && depthBufferValue <= sampleDepth) {
				occlusion +=  1.0;
			}
			
		}         
		   
		occlusion = 1.0 - occlusion / float(kernelSize);
                                   
		vec3 lightPos = vec3(10.0, 10.0, 10.0);
        vec3 L = normalize(lightPos);
		float NdotL = abs(dot(normal, L));
		vec3 diffuse = vec3(NdotL);
		vec3 ambient = vec3(1.0);
	    gl_FragColor.rgb = vec3((diffuse*0.2 + ambient*0.8) * occlusion);
		//gl_FragColor.rgb = normal;
	    gl_FragColor.a = 1.0;   
	}
</script>  
<script type="glsl" id="blur.frag">  
	uniform sampler2D colorTex;
	uniform vec2 texelSize;
	varying vec2 vTexCoord; 	 	

	void main() {
		vec3 result = vec3(0.0);
		for (int i = 0; i < 4; ++i) {
			for (int j = 0; j < 4; ++j) {
				vec2 offset = vec2(texelSize.x * float(j), texelSize.y * float(i));
				result += texture2D(colorTex, vTexCoord + offset).rgb;
			}
		}
		       
		gl_FragColor.rgb = vec3(result * 0.0625); 
		gl_FragColor.a = 1.0;
	}
</script>
<style type="text/css">
	body {
		margin: 0;  
		background: #000;
	}        
	#canvas {    
		width: 1024px;
		margin: 0 auto; 
		display: block;
	}
</style>
</head>
<body>	    
	<canvas id="canvas" width="1024" height="512"></canvas> 
		

</body></html>